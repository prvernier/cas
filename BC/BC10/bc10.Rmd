---  
title: "BC10 Inventory"
date: "Updated: `r format(Sys.time(), '%d %B %Y')`"
output:  
  html_document:  
    toc: true
    toc_float:
      collapsed: true
    code_folding: hide
    css: ../../styles.css
---  

```{r echo=FALSE, message=FALSE, warning=FALSE}  
x=bc10
```

# CAS Attributes

## CAS_ID

The attribute **cas_id** attribute is a concatenation of several attributes and strings i.e., "bc10", src_filename, map_id, feature_id, ogc_fid.

## ORIG_STAND_ID

  * source attribute: attribute l1_feature_id

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_feature_id"], graph.col=FALSE)
dfSummary(x["orig_stand_id"], graph.col=FALSE)
```

## STAND_STRUCTURE

  * NOTE: this attribute will be generated using SQL helper functions
  * source attributes: l1_layer_id and l2_layer_id

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["stand_structure"], graph.col=FALSE)
```

## NUM_OF_LAYERS

  * NOTE: this attribute will be generated using SQL helper functions
  * source attributes: l1_layer_id and l2_layer_id

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["num_of_layers"], graph.col=FALSE)
```

## IDENTIFICATION_ID

  * The attribute **identification_id** is created from the attribute inventory_standard_cd:
    - F = Forest Inventory Planning (FIP)
    - V = full VRI
    - I = incomplete VRI
    - L = Landscape Vegetation Inventory (LVI); low cost alternative to VRI

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["inventory_standard_cd"], graph.col=FALSE)
dfSummary(x["identification_id"], graph.col=FALSE)
```

## MAP_SHEET_ID

  * Source attribute: map_id

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["map_id"], graph.col=FALSE, max.distinct.values=10)
dfSummary(x["map_sheet_id"], graph.col=FALSE, max.distinct.values=10)
```

## GIS_AREA

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["feature_area_sqm"], graph.col=FALSE)
dfSummary(x["gis_area"], graph.col=FALSE)
```

## GIS_PERIMETER

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["feature_length_m"], graph.col=FALSE)
dfSummary(x["gis_perimeter"], graph.col=FALSE)
```

## INVENTORY_AREA

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["feature_area_sqm"], graph.col=FALSE)
dfSummary(x["inventory_area"], graph.col=FALSE)
```

## PHOTO_YEAR

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["reference_year"], graph.col=FALSE)
dfSummary(x["photo_year"], graph.col=FALSE)
```

# LYR Attributes

## SOIL_MOIST_REG

  * source attribute: soil_moisture_regime_1

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["soil_moisture_regime_1"], graph.col=FALSE)
dfSummary(x["soil_moist_reg"], graph.col=FALSE)
```

## STRUCTURE_PER

  * NOTE: this attribute will be generated using SQL helper functions

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["structure_per"], graph.col=FALSE)
```


## LAYER

  * NOTE: this attribute will be generated using SQL helper functions

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_layer_id"], graph.col=FALSE)
dfSummary(x["layer"], graph.col=FALSE)
```

## LAYER_RANK

  * NOTE: this attribute will be generated using SQL helper functions
  * source attribute: l1_for_cover_rank_cd

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_for_cover_rank_cd"], graph.col=FALSE)
dfSummary(x["layer_rank"], graph.col=FALSE)
```

## CROWN_CLOSURE

  * Source attribute: l1_crown_closure

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_crown_closure"], graph.col=FALSE)
dfSummary(x["crown_closure_upper"], graph.col=FALSE)
dfSummary(x["crown_closure_lower"], graph.col=FALSE)
```

## HEIGHT 

  * Source attribute: l1_proj_height

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_proj_height_1"], graph.col=FALSE)
dfSummary(x["height_upper"], graph.col=FALSE)
dfSummary(x["height_lower"], graph.col=FALSE)
```

## PRODUCTIVE_FOR

  * source attribute: for_mgmt_land_base_ind

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["for_mgmt_land_base_ind"], graph.col=FALSE)
dfSummary(x["productive_for"], graph.col=FALSE)
```

## SPECIES

  * source attributes: l1_species_cd_1 - l1_species_cd_6

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_species_cd_1"], graph.col=FALSE)
dfSummary(x["species_1"], graph.col=FALSE)
```

## SPECIES_PER

  * source attributes: l1_species_cd_1 - l1_species_cd_6

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_species_pct_1"], graph.col=FALSE)
dfSummary(x["species_per_1"], graph.col=FALSE)
```

## ORIGIN

  * source attribute: l1_proj_age_1

```{r echo=FALSE, message=FALSE, warning=FALSE}  
#dfSummary(x["projected_date"], graph.col=FALSE)
#dfSummary(x["projected_year"], graph.col=FALSE)
dfSummary(x["l1_proj_age_1"], graph.col=FALSE)
dfSummary(x["origin_upper"], graph.col=FALSE)
dfSummary(x["origin_lower"], graph.col=FALSE)
```

## SITE_CLASS

  * source_attribute: site_index if available or est_site_index otherwise

## SITE_INDEX

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["l1_site_index"], graph.col=FALSE)
dfSummary(x["l1_est_site_index"], graph.col=FALSE)
dfSummary(x["site_index"], graph.col=FALSE)
```


# NFL Attributes

Based on the CAS_04 database, NFL polygons do not overlap LYR polygons. In other words, a forested polygon cannot also include information on land cover components that occur within the boundaries and vice versa. **This was changed so that polygons can now have both LYR and NFL attributes i.e., removed for_mgmt_land_base_ind=="N" from code (2019-06-16)**

Some specific notes:

  * Here we create NFL attributes for polygons where for_mgmt_land_base_ind=="N". This attribute is new (<a href="https://www2.gov.bc.ca/assets/gov/farming-natural-resources-and-industry/forestry/stewardship/forest-analysis-inventory/data-management/standards/forest_management_land_base_definition.pdf">see PDF</a>). **Is this preferable to using crown_closure (as suggested by CASFRI or species_cd_1 as used in Perl code).**
  * The key FRI attributes are for "V" and "I" are land_cover_class_cd_1, non_veg_cover_type1, and bclcs_level4
  * The key FRI attributes are for "F" are non_productive_descriptor_cd and bclcs_level4
  * The order FRI attributes are processed is important; a polygon can have a value for 1 or 2 of those attributes, they are not exclusive.
  * The fri and cas parameters in the mapvalues function (see code sections below) are specific to the FRI and CAS attributes and are described in the accompanying spreadsheet (bc08_nfl.xlsx). **The Excel file needs to be converted to CSV files**.

## NAT_NON_VEG

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["nat_non_veg"], graph.col=FALSE)
```

## NON_FOR_ANTH

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["non_for_anth"], graph.col=FALSE)
```

## NON_FOR_VEG

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["non_for_veg"], graph.col=FALSE)
```

## SOIL_MOIST_REG

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x$soil_moisture_regime_1[!x$nfl_soil_moist_reg=="NULL_VALUE"], graph.col=FALSE)
dfSummary(x["nfl_soil_moist_reg"], graph.col=FALSE)
```

## STRUCTURE_PER

  * CAS_04 has one distinct value for this attribute: -8888
  * **How is this calculated and how does it relate to the same attribute in the LYR group?**
  * Use null value integer error code: -8887

## LAYER

  * CAS_04 has one distinct value for this attribute: 1
  * Use null value integer error code: -8887

## LAYER_RANK

  * CAS_04 has one distinct value for this attribute: 1
  * Use null value integer error code: -8887

## CROWN_CLOSURE

  * The CASFRI attribute is renamed to nfl_crown_closure to avoid conflict with LYR attribute of same name
  * The source attribute used is l1_crown_closure since NFL attributes are not distinguished by layer

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x$l1_crown_closure[!x$nfl_crown_closure_upper=="NULL_VALUE"], graph.col=FALSE)
dfSummary(x["nfl_crown_closure_upper"], graph.col=FALSE)
dfSummary(x$l1_crown_closure[!x$nfl_crown_closure_lower=="NULL_VALUE"], graph.col=FALSE)
dfSummary(x["nfl_crown_closure_lower"], graph.col=FALSE)
```

## HEIGHT

  * The CASFRI attribute is renamed to nfl_height_uppeer to avoid conflict with LYR attribute of same name
  * The source attribute used is l1_proj_height_1 since NFL attributes are not distinguished by layer

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x$l1_proj_height_1[!x$nfl_height_upper==-8888], graph.col=FALSE)
dfSummary(x["nfl_height_upper"], graph.col=FALSE)
dfSummary(x$l1_proj_height_1[!x$nfl_height_lower==-8888], graph.col=FALSE)
dfSummary(x["nfl_height_lower"], graph.col=FALSE)
```


# DST Attributes

  * Only DIST_1, DIST_YR_1, and LAYER seem to have values in the CAS_04.
  * **Should we add the other attributes?**
  * All attributes should be carefully reviewed...

## DIST_TYPE_1

  * The attributes **dist_1** and **dist_yr_1** seem to be taken from *line_7b_disturbance_history*. From the BC metadata: "The disturbance history described as a list of abbreviations for the techniques along with the years each technique was employed. Possible values are B (wildfire), BE (escaped burn), BG (ground burn), BR (range burn), BW (wildlife burn), D (disease), F (flooding), I (insect), K (fume kill), L (logging), L% (logged with percentage), R (site rehabilitation), S (slide), and W (wind throw)."
  * These codes don't seem to match up with the BC data
  * "M" and "P" occur in data but are not in metadata or Perl code
  * "W", "K", "S", "F", "G", "Y", "T", "V" do not occur in the data but are in Perl code
  * "N" -> "UK" is a new disturbance code defined by SC in Perl code

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["mod1"], graph.col=FALSE)
dfSummary(x["dist_type_1"], graph.col=FALSE)
```

## DIST_YEAR_1

  * CAS_04 uses mod1yr>10 as cut-off between the 1900s and 2000s but that doesn't seem right; here we use 17.

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["mod1yr"], graph.col=FALSE)
dfSummary(x$dist_year_1, graph.col=FALSE)
```

## DIST_EXT_UPPER_1, DIST_EXT_LOWER_1

  * value = -8888 in cas04
  * There is some Perl code to calculate this but it is commented out

## DIST_TYPE_2

* value = "-8888" in cas04

## DIST_YEAR_2

* value = -8888 in cas04

## DIST_EXT_UPPER_1, DIST_EXT_LOWER_1

* value = -8888 in cas04

## DIST_TYPE_3

* value = ""-8888" in cas04

## DIST_YEAR_3

* value = -8888 in cas04

## DIST_EXT_UPPER_1, DIST_EXT_LOWER_1

* value = -8888 in cas04

## LAYER

  * value = 1 in cas04

# ECO Attributes

  * The first four attributes are created from several BC inventory attributes: non_productive_descriptor_cd, l1_non_forest_descriptor, land_cover_class_cd_1, soil_moisture_regime_1, species_cd_1, species_pct_1, species_cd_2, crown_closure, and proj_height_1.
  * Only layer 1 (l1_) attributes used (?)

## WETLAND_TYPE
```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["wetland_type"], graph.col=FALSE)
```

## WET_VEG_COVER
```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["wet_veg_cover"], graph.col=FALSE)
```

## WET_LANDFORM_MOD
```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["wet_landform_mod"], graph.col=FALSE)
```

## WET_LOCAL_MOD
```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["wet_local_mod"], graph.col=FALSE)
```

## ECO_SITE

  * Concatenated from bec_zone_code, bec_subzone, bec_variant, bec_phase, site_position_meso
  * Added a "." between attributes and "" if attribute is null

```{r echo=FALSE, message=FALSE, warning=FALSE}  
dfSummary(x["eco_site"], graph.col=FALSE)
```
